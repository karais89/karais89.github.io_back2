---
layout: post
title: "The Go Programming Language #2: 프로그램 구조"
subtitle: "The Go Programming Language 책 내용 정리"
author: "karais89"
header-img: "img/post-bg-golang.jpg"
header-mask: 0.4
catalog: true
tags: [gopl, golang]
---

> The Go Programming Language 책 내용 정리

## 개요
- 책 자체는 레퍼런스 책으로 좋아 보인다.
- 책에 모든 내용을 정리하기에는 힘들 것으로 보인다.
- 책 전체 내용을 한번 훑어 보고, Go만의 특별한 내용만 정리하는 형태를 취해야 될 것으로 보인다.
- 포스트 자체는 하지만 해당 포스트가 마음에 안들어 언제든지 제거할 수도 있을 것 같다.

## 2.1 이름

Go의 경우 함수, 변수, 상수, 타입, 구문 라벨, 패키지 등의 이름은 간단한 규칙을 따른다.

- 이름은 문자(유니코드에서 문자로 간주하는 것 모두)나 밑줄로 시작한다.
- 그 뒤에 임의의 개수의 부가적인 문자, 숫자, 밑줄을 쓸 수 있다.
- 대소문자를 구별한다
- Go에서 제공하는 키워드(if나 else등 약25개)는 이름으로 사용할 수 없다

> 이름이 대문자로 시작하면 익스포트돼 자신의 패키지 밖에서 보거나 사용할 수 있다 (Public)

- Go 프로그램은 짧은 이름을 선호한다
- 일반적으로 카멜 표기법을 사용한다.
- ASCII나 HTML과 같은 약어는 항상 모두 대문자나 소문자로 표기한다.
    - htmlEscape, HTMLEscape, escapeHTML등으로 명명한다. (escapeHtml으로 명명하지 않음)

## 2.2 선언

> 선언에는 주로 var, const, type, func의 네가지 종류가 있다.

### boiling

```go
package main

import "fmt"

const boilingF = 212.0 // 패키지 수준의 상수 선언

func main() {
	var f = boilingF         // main 함수의 지역 변수
	var c = (f - 32) * 5 / 9 // main 함수의 지역 변수
	fmt.Printf("boiling point = %g F or %g C\n", f, c)
	// 출력:
	// boiling point = 212 F or 100 C
}
```

- 선언의 예 (상수, 변수)

### ftoc

```go
package main

import "fmt"

func main() {
	const freezingF, boilingF = 32.0, 212.0
	fmt.Printf("%g F = %g C\n", freezingF, fToC(freezingF)) // 32 F = 0 C
	fmt.Printf("%g F = %g C\n", boilingF, fToC(boilingF))   // 212 F = 100 C
}

func fToC(f float64) float64 {
	return (f - 32) * 5 / 9
}
```

- 함수 사용의 예

## 2.3 변수

var 선언은 특정 타입의 변수를 만들고 이름을 붙인 뒤 초기 값을 설정한다.

> var 이름 타입 = 표현식

```go
var s string
fmt.Println(s) //""
```

- Go에는 초기화되지 않은 변수가 없다.

```go
var i, j, k int // int, int, int
var b, f, s = true, 2.3, "four" // bool, float64, string
```

- 타입을 생략하면 서로 다른 타입의 여러 변수를 선언할 수 있다.

```go
var f, err = os.Open(name) // os.Open은 파일과 오류를 반환한다.
```

- 여러 값을 반환하는 함수를 호출해 여러 변수를 초기화 할 수 있다. (c#의 튜플과 비슷)

### 2.3.1 짧은 변수 선언

짧은 변수 선언

> 이름 := 표현식

```go
anim := gif.GIF{LoopCount: nframes}
freq := rand.Float64() * 3.0
t := 0.0
```

- 간결함과 유연성으로 인해 대부분의 지역 변수는 짧은 변수 선언으로 선언되고 초기화된다.

```go
i := 100 // an int
var boiling float64 = 100 // a float64

var names []string
var err error
var p Point
```

- var 선언은 초기화 표현식과 다른 명시적인 타입이 필요하거나 값이 나중에 할당돼 초기 값이 중요하지 않은 경우에 한정되는 경향이 있다.

```go
i, j := 0, 1
```

- 짧은 변수 선언으로 여러 변수를 선언하거나 초기화할 수 있다.

```go
f, err := os.Open(name)
if err != nil {
	return err
}

// ...f 사용...
f.Close()
```

- var 선언과 마찬가지로 두 개 이상의 값을 반환하는 os.Open과 같은 호출에 사용 할 수 있다.

```go
in, err := os.Open(infile) // in, err 모두 선언
// ...
out, err := os.Create(outfile) // out은 선언, err 변수는 할당
```

- 중요한 점은, 짧은 변수 선언에서 왼쪽에 있는 모든 변수를 반드시 선언할 필요는 없다는 점이다. 그 중 일부가 이미 같은 어휘 블록에 선언돼 있는 경우에는 짧은 변수 선언이 해당 변수에 값을 할당한다.
- 짧은 변수 선언은 적어도 하나의 새로운 변수를 선언해야 한다.

### 2.3.2 포인터

포인터 값은 변수의 주소다. 모든 변수에는 주소가 있다.

```go
x := 1
p := &x // *int 타입 p는 x를 가리킨다.
fmt.Println(*p) // 1
*p = 2 // x = 2와 같다.
fmt.Println(x) // 2
```

- c의 포인터와 개념은 같지만 제약이 있다.

```go
var p = f()
func f() *int {
	v := 1
	return &v
}

fmt.Println(f() == f()) // "false" f를 호출할 때마다 다른 값을 반환
```

- 함수는 지역변수의 주소를 반환할 수 있다.
- 함수 f를 호출해 생성된 지역변수 v는 호출이 반환된 후에도 존재하며, 포인터 p는 해당 값을 계속 참조할 수 있다.

```go
func incr(p *int) int {
	*p++ // p가 가르키는 값을 증가시킨다. p는 변경하지 않는다.
	return *p
}

v := 1
incr(&v) // 2
fmt.Println(incr(&v)) // 3
```

### 2.3.3 new 함수

변수를 생성하는 또 다른 방법은 내장된 new 함수를 사용하는 것

```go
p := new(int) // *int 타입 p는 이름 없는 int 변수를 가리킨다.
fmt.Println(*p) // 0
*p = 2
fmt.Println(*p) // 2
```

- new(T) 표현식은 T 타입의 이름 없는 변수를 만들고 T의 제로 값으로 초기화 한 후 *T 타입의 값인 변수의 주소를 반환한다.

```go
func newInt() *int {
	return new(int)
}

func newInt() *int {
	var dummy int
	return &dummy
}
```

- newInt 함수는 동일하게 동작한다.

### 2.3.4 변수의 수명

패키지 수준 변수의 수명은 프로그램의 전체 실행 기간과 같다.

지역 변수의 수명은 동적이다.

> 컴파일러는 지역 변수를 힙이나 스택 중 어디에 할당할지 결정한다.

```go
var global *int
func f() {
	var x int
	x = 1
	global = &x
}
```

- x는 지역변수로 선언되었지만, f가 반환된 이후에도 global 변수로 접근 가능하므로 힙 영역에 할당 된다.

```go
func g() {
	y := new(int)
	*y = 1
}
```

- *y는 g에서 벗어날 수 없기 때문에 스택에 할당된다.

## 2.4 할당

```go
x = 1 // 명명된 변수
*p = true // 간접 변수
person.name = "bob" // 구조체 필드
count[x] = count[x] * scale // 배열이나 슬라이스 또는 맵 원소
count[x] *= scale // 위와 동일
v := 1
v++ // v = v + 1과 같다. v는 2가 된다.
v-- // v = v - 1과 같다. v는 다시 1이 된다/
```

### 2.4.1 튜플 할당

여러 변수를 동시에 할당하는 튜플 할당.

```go
x, y = y, x
a[i], a[j] = a[j], a[i]
```

- 오른쪽의 모든 표현식은 변수가 갱신되기 전에 평가된다.
- 변수의 스왑

```go
// 최대 공약수
func gcd(x, y int) int {
	for y != 0 {
		x, y = y, x%y	
	}
	return x
}

// 피보나치
func fib(n int) int {
	x, y := 0, 1
	for i := 0; i < n; i++ {
		x,y = y, x+y
	}
	return x
}
```

## 2.5 타입 선언

type 선언은 기존 타입과 같은 내부 타입을 갖는 새 명명된 타입을 정의한다.

> type 이름 내부-타입

### tempconv0

```go
package tempconv0

type Celsius float64
type Fahrenheit float64

const (
	AbsoluteZeroC Celsius = -273.15
	FreezingC     Celsius = 0
	BoilingC      Celsius = 100
)

func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }
func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }
```

- 서로 다른 온도 단위를 다른 타입으로 변환
- 명시적으로 값의 의미를 변경하여 실수를 방지할 수 있다.

## 2.6 패키지와 파일

Go의 패키지는 다른 언어의 라이브러리나 모듈과 마찬가지로 모듈화, 캡슐화, 분할 컴파일 및 재사용 등을 지원한다.

tempconv 패키지 생성

```go
// tempconv/tempconv.go
package tempconv

import "fmt"

type Celsius float64
type Fahrenheit float64

const (
	AbsoluteZeroC Celsius = -273.15
	FreezingC     Celsius = 0
	BoilingC      Celsius = 100
)

func (c Celsius) String() string { return fmt.Sprintf("%g C", c)}
func (f Fahrenheit) String() string { return fmt.Sprintf("%g F", f)}
```

```go
// tempconv/conv.go
package tempconv

func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }
func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }
```

```go
// 패키지 사용
func main() {
	fmt.Printf("Brrrr! %v\n", tempconv.AbsoluteZeroC)
	fmt.Println(tempconv.CToF(tempconv.BoilingC))
}
```

### 2.6.1 임포트

Go 프로그램 안의 모든 패키지는 임포트 경로라는 고유한 문자열로 식별된다.