---
layout: post
title: "The Go Programming Language #1.6 URL 동시 반입"
subtitle: "The Go Programming Language 책 내용 정리"
author: "karais89"
header-img: "img/post-bg-golang.jpg"
header-mask: 0.4
catalog: true
tags: [gopl, golang]
---

> The Go Programming Language 책 내용 정리

## 1.6 URL 동시 반입

Go의 가장 흥미롭고 기발한 측면 중 하나는 `동시성 프로그램`에 대한 지원이다.

고루틴과 채널에 대해 간단하게 살펴본다.

### fetchall

```go
package main

import (
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"time"
)

func main() {
	start := time.Now()
	ch := make(chan string) // 채널 생성
	for _, url := range os.Args[1:] {
		go fetch(url, ch) // 고루틴 시작
	}
	for range os.Args[1:] {
		fmt.Println(<-ch) // ch 채널 에서 수신
	}
	fmt.Printf("%.2fs elapsed\n", time.Since(start).Seconds())
}

func fetch(url string, ch chan<- string) {
	start := time.Now()
	resp, err := http.Get(url)
	if err != nil {
		ch <- fmt.Sprint(err) // ch 채널로 송신
		return
	}
	nbytes, err := io.Copy(ioutil.Discard, resp.Body)
	resp.Body.Close() // 리소스 누출 방지
	if err != nil {
		ch <- fmt.Sprintf("while reading %s: %v", url, err) // ch 채널로 송신
		return
	}
	secs := time.Since(start).Seconds()
	ch <- fmt.Sprintf("%.2fs %7d %s", secs, nbytes, url)
}
```

- 동시에 여러 url에서 가져오기 때문에 전체 처리 시간은 각 반입 시간의 합이 아니라 가장 오래 걸릴 때의 시간이 된다. (병렬 처리)
- ioutil.Discard에 출력해 폐기

실행 방법 및 결과

```bash
> go run fetchall/main.go https://golang.org http://gopl.io https://godoc.org

0.38s   10313 https://golang.org
0.96s   10413 https://godoc.org
1.22s    4154 http://gopl.io
1.22s elapsed
```

### exam1-10

- 많은 양의 데이터를 생성하는 웹사이트를 찾아라. fetchall을 두 번 연속으로 실행하고 결과 시간이 얼마나 달라지는지를 통해 캐시 여부를 조사하라. 매번 같은 내용을 받는가? 이 결과를 조사하기 위해 fetchall이 결과를 파일로 출력하게 수정하라.

### exam1-11

- alexa.com에 있는 상위 100만 사이트와 같은 샘플을 이용해 더 긴 인자 목록으로 fetchall을 실행해보라. 웹사이트가 응답하지 않을 경우 프로그램이 어떻게 작동하는가?