---
layout: post
title: "The Go Programming Language #1.1 ~ 1.6"
subtitle: "The Go Programming Language 책 내용 정리"
author: "karais89"
header-img: "img/post-bg-golang.jpg"
header-mask: 0.4
catalog: true
tags: [gopl, golang]
---

> The Go Programming Language 책 내용 정리

Go 언어는 단순성이 가장 큰 특징인 언어이다.
이 책은 그러한 단순성에 대한 설계 사상을 보여준다.
Go의 설계 사상은 유닉스의 설계 사상과 매우 유사하며, 작고 간단한 기능을 조합해 복잡한 기능을 구현한다.

Go는 C와 비슷한 문법을 사용하며 전문 개발자들이 최대한의 효과를 최소한의 노력으로 얻기 위한 도구이다.

- Go는 정확하게 필요한 패키지만을 임포트해야 한다.
- Go는 세미콜론을 요구하지 않는다.
- Go는 코드 서식에 강경한 입장을 취한다.

## 1.1 Hello, World

### helloworld

```go
package main

import "fmt"

func main() {
	fmt.Println("Hello, world!")
}
```

- go fmt의 경우 goland에서 go tools → go fmt file (goland 메뉴)을 사용하여 실행.
- Run 'go build main.go' (goland 메뉴)
    - go run main.go
    - go build main.go
- 가장 기본적인 예제


## 1.2 커맨드 라인 인수

- 슬라이스: 동적인 크기를 갖는 배열 원소의 모음 정도로 생각
- 변수 선언 중 값을 명시적으로 초기화 하지 않은 경우 제로값으로 초기화 됨 (0, "")
- := 기호는 짧은 변수 선언

### echo1

```go
// chapter01/echo1/main.go
package main

import "fmt"
import "os"

func main() {
	var s, sep string
	for i := 1; i < len(os.Args); i++ {
		s += sep + os.Args[i]
		sep = " "
	}
	fmt.Println(s)
}
```
- go run main.go 1 first args 명령어 등으로 인자 삽입
- or goland 설정에서 인자 삽입 가능 (Program arguments)

### Go의 유일한 반복문 for문

```go
// 일반적인 for문
for 초기화; 조건; 후처리 {

}

// while 문
for 조건 {

}

// 무한 루프
for {

}
```

### echo2

```go
package main

import "fmt"
import "os"

func main() {
	s, sep := "", ""
	for _, arg := range os.Args[1:] {
		s += sep + arg
		sep = " "
	}
	fmt.Println(s)
}
```

- for문으로 슬라이스 값 범위에 걸쳐 반복되는 형태도 가능하다.
- range은 각 반복에서 값의 쌍을 생성한다. (인덱스와 원소의 값)

### echo3

```go
package main

import (
	"fmt"
	"os"
	"strings"
)

func main() {
	fmt.Println(strings.Join(os.Args[1:], " "))
}
```

- strings 패키지의 join 함수 사용

### exam 1-1

```go
package main

func main() {
	fmt.Println(strings.Join(os.Args, " "))
}
```

- os.Args[0]도 같이 출력

### exam 1-2

```go
package main

import "fmt"
import "os"

func main() {
	for i, arg := range os.Args[1:] {
		fmt.Println(i, arg)
	}
}
```

- 각 인자의 인덱스와 값을 한 줄에 하나씩 출력

### exam 1-3

```go
package main

import (
	"fmt"
	"os"
	"strconv"
	"strings"
	"time"
)

func main() {
	start := time.Now()
	var s, sep string
	for i := 1; i < 10000; i++ {
		s += sep + strconv.Itoa(i)
		sep = " "
	}
	fmt.Println(s)
	fmt.Println(strings.Join(os.Args[1:], " "))
	duration := time.Since(start)
	fmt.Println(duration.Nanoseconds())

}
```

- 비 효율적 버전과 string.join을 사용하는 버전의 시간 체크
- time 패키지 사용
- 위 방식을 사용하는 것 같은데 너무 빨리 되기 때문에 체크가 안됨. 벤치마크 하는 방법을 사용해야 됨.

## 1.3 중복 줄 찾기

### dup1

```go
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	counts := make(map[string]int)
	input := bufio.NewScanner(os.Stdin)
	for input.Scan() {
		counts[input.Text()]++
	}
	// note: input.Err()에서의 잠재적 오류는 무시한다.
	for line, n := range counts {
		if n > 1 {
			fmt.Printf("%d\t%s\n", n, line)
		}
	}
}
```

- if문, map 데이터 타입 및 bufio 패키지 사용
- 맵은 해당 키가 없는 경우에도 문제가 없다. (제로키 반환 int의 경우 0)
- 실행 후 입력 및 ctrl + d로 종료.

### dup2

```go
// dup2는 입력에서 두 번 이상 나타나는 각 줄의 카운트와 텍스트를 출력한다.
// 이 프로그램은 표준 입력이나 파일 목록에서 읽는다.
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	counts := make(map[string]int)
	files := os.Args[1:]
	if len(files) == 0 {
		countLines(os.Stdin, counts)
	} else {
		for _, arg := range files {
			f, err := os.Open(arg)
			if err != nil {
				fmt.Fprint(os.Stderr, "dup2: %v\n", err)
				continue
			}
			countLines(f, counts)
			f.Close()
		}
	}
	for line, n := range counts {
		if n > 1 {
			fmt.Printf("%d\t%s\n", n, line)
		}
	}
}

func countLines(f *os.File, counts map[string]int) {
	input := bufio.NewScanner(f)
	for input.Scan() {
		counts[input.Text()]++
	}
	// note: input.err()에서의 잠재적 오류는 무시한다.
}
```

- 표준 입력을 읽거나 파일명의 목록을 받아 각각 os.open으로 열고 처리 하는 예제
- 표준 입력도 File 클래스 사용. os도 File 클래스 사용

### dup3

```go
package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"strings"
)

func main() {
	counts := make(map[string]int)
	for _, filename := range os.Args[1:] {
		data, err := ioutil.ReadFile(filename)
		if err != nil {
			fmt.Fprintf(os.Stderr, "dup3: %v\n", err)
			continue
		}
		for _, line := range strings.Split(string(data), "\n") {
			counts[line]++
		}
	}
	for line, n := range counts {
		if n > 1 {
			fmt.Printf("%d\t%s\n", n, line)
		}
	}
}
```

- 명명된 파일의 모든 내용을 읽는 ReadFile 사용
- 여러 부분 문자열들로 구분하는 strings.Split 사용
- byte[] 슬라이스(data)를 string으로 변환
- ./chapter01/dummy.txt

### exam1-4

```go
// dup2는 입력에서 두 번 이상 나타나는 각 줄의 카운트와 텍스트를 출력한다.
// 이 프로그램은 표준 입력이나 파일 목록에서 읽는다.
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	counts := make(map[string]int)
	filenames := make(map[string]bool)
	for _, arg := range os.Args[1:] {
		f, err := os.Open(arg)
		if err != nil {
			fmt.Fprint(os.Stderr, "dup2: %v\n", err)
			continue
		}
		countLines(f, counts, arg, filenames)
		f.Close()
	}

	for name, n := range filenames {
		if n {
			fmt.Printf("%s\n", name)
		}
	}
}

func countLines(f *os.File, counts map[string]int, filename string, filenames map[string]bool) {
	input := bufio.NewScanner(f)
	for input.Scan() {
		text := input.Text()
		counts[text]++
		if counts[text] > 1 {
			filenames[filename] = true
		}
	}
	// note: input.err()에서의 잠재적 오류는 무시한다.
}
```

- dup2를 수정해서 중복된 줄이 있는 파일명을 모두 출력하라.
- 다른 좋은 방법이 있을 것 같긴 한데.. 그냥 이렇게 해결함.


## 1.4 애니메이션 GIF

Go에 내장된 표준 이미지 패키지에 대한 소개

### lissajous

```go
// Lissajous는 임의의 리사주 형태의 애니메이션 gif를 생성한다.
package main

import (
	"image"
	"image/color"
	"image/gif"
	"io"
	"math"
	"math/rand"
	"os"
)

var palette = []color.Color{color.White, color.Black}

const (
	whiteIndex = 0 // 팔레트의 첫 번째 색상
	blackIndex = 1 // 팔레트의 다음 색상
)

func main() {
	lissajous(os.Stdout)
}

func lissajous(out io.Writer) {
	const (
		cycles  = 5     // x 진동자의 회전수
		res     = 0.001 // 회전각
		size    = 100   // 이미지 캔버스 크기 [-size..+size]
		nframes = 64    // 애니메이션 프레임 수
		delay   = 8     // 10ms 단위의 프레임 간 지연
	)
	freq := rand.Float64() * 3.0 // y 진동자의 상대적 진동수
	anim := gif.GIF{LoopCount: nframes}
	phase := 0.0 // 위상 차이
	for i := 0; i < nframes; i++ {
		rect := image.Rect(0, 0, 2*size+1, 2*size+1)
		img := image.NewPaletted(rect, palette)
		for t := 0.0; t < cycles*2*math.Pi; t += res {
			x := math.Sin(t)
			y := math.Sin(t*freq + phase)
			img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5), blackIndex)
		}
		phase += 0.1
		anim.Delay = append(anim.Delay, delay)
		anim.Image = append(anim.Image, img)
	}
	gif.EncodeAll(out, &anim) // note: 인코딩 오류 무시
}
```

- const 선언, 구조체 타입, 복합 리터럴에 대해 사용.
- 부동 소수점 연산 사용
- go build main.go
- main.exe > out.gif

    ![gif 이미지](/img/in-post/golang/2021-02-26-01.gif)

- 이 부분의 연습문제는 넘어감.

## 1.5 URL 반입

Go는 net 그룹의 하위 패키지로 인터넷을 통해 정보를 주고받고 저수준 네트워크 연결을 생성하고, 서버를 설정하기 쉽게 하는 패키지들을 제공한다. 이는 Go의 동시성에 특히 유용한 부분이다.

### fetch

```go
package main

import (
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
)

func main() {
	for _, url := range os.Args[1:] {
		resp, err := http.Get(url)
		if err != nil {
			fmt.Fprintf(os.Stderr, "fetch: %v\n", err)
			os.Exit(1)
		}
		b, err := ioutil.ReadAll(resp.Body)
		resp.Body.Close()
		if err != nil {
			fmt.Fprintf(os.Stderr, "fetch: reading %s: %v\n", url, err)
			os.Exit(1)
		}
		fmt.Printf("%s", b)
	}
}
```

- url에서 내용을 가져오고 원본 그대로 출력하는 예제
- net/http와 io/ioutil의 함수 사용
- ReadAll은 전체 응답을 읽는다. http.get으로 받은 body는 위와 같은 형태로 읽는다고 생각하면 됨.

### exam1-7

```go
package main

import (
	"fmt"
	"io"
	"net/http"
	"os"
)

func main() {
	for _, url := range os.Args[1:] {
		resp, err := http.Get(url)
		if err != nil {
			fmt.Fprintf(os.Stderr, "fetch: %v\n", err)
			os.Exit(1)
		}
		_, err = io.Copy(os.Stdout, resp.Body)
		resp.Body.Close()
		if err != nil {
			fmt.Fprintf(os.Stderr, "fetch: reading %s: %v\n", url, err)
			os.Exit(1)
		}
	}
}
```

- io.copy(dst, src) 함수를 ioutil.ReadAll 대신 사용. os.Stdout로 복사 후 에러 확인
    - 에러는 발생하지 않음 원래는 버퍼 문제등으로 에러가 발생하는 것 같은데 버퍼가 크나?

### exam1-8

```go
package main

func main() {
	for _, url := range os.Args[1:] {
		if !strings.HasPrefix(url, "http://") {
			url = "http://" + url
		}
		
		// .. 아래 코드는 fetch와 동일		
	}
}
```

- http:// 접두사가 누락된 경우도 정상적으로 동작 가능하게 변경
- HasPrefix로 접두사 검사 후 없으면 추가 하는 방식

### exam1-9

```go
package main

func main() {
	for _, url := range os.Args[1:] {
		// .. fetch와 동일
		fmt.Printf("status Code: %d\n", resp.StatusCode)
		fmt.Printf("%s", b)
	}
}
```

- fetch를 수정해 resp.Status에 있는 HTTP 응답 코드도 같이 출력

## 1.6 URL 동시 반입

Go의 가장 흥미롭고 기발한 측면 중 하나는 `동시성 프로그램`에 대한 지원이다.

고루틴과 채널에 대해 간단하게 살펴본다.

### fetchall

```go
package main

import (
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"time"
)

func main() {
	start := time.Now()
	ch := make(chan string) // 채널 생성
	for _, url := range os.Args[1:] {
		go fetch(url, ch) // 고루틴 시작
	}
	for range os.Args[1:] {
		fmt.Println(<-ch) // ch 채널 에서 수신
	}
	fmt.Printf("%.2fs elapsed\n", time.Since(start).Seconds())
}

func fetch(url string, ch chan<- string) {
	start := time.Now()
	resp, err := http.Get(url)
	if err != nil {
		ch <- fmt.Sprint(err) // ch 채널로 송신
		return
	}
	nbytes, err := io.Copy(ioutil.Discard, resp.Body)
	resp.Body.Close() // 리소스 누출 방지
	if err != nil {
		ch <- fmt.Sprintf("while reading %s: %v", url, err) // ch 채널로 송신
		return
	}
	secs := time.Since(start).Seconds()
	ch <- fmt.Sprintf("%.2fs %7d %s", secs, nbytes, url)
}
```

- 동시에 여러 url에서 가져오기 때문에 전체 처리 시간은 각 반입 시간의 합이 아니라 가장 오래 걸릴 때의 시간이 된다. (병렬 처리)
- ioutil.Discard에 출력해 폐기

실행 방법 및 결과

```bash
> go run fetchall/main.go https://golang.org http://gopl.io https://godoc.org

0.38s   10313 https://golang.org
0.96s   10413 https://godoc.org
1.22s    4154 http://gopl.io
1.22s elapsed
```

### exam1-10

- 많은 양의 데이터를 생성하는 웹사이트를 찾아라. fetchall을 두 번 연속으로 실행하고 결과 시간이 얼마나 달라지는지를 통해 캐시 여부를 조사하라. 매번 같은 내용을 받는가? 이 결과를 조사하기 위해 fetchall이 결과를 파일로 출력하게 수정하라.

### exam1-11

- alexa.com에 있는 상위 100만 사이트와 같은 샘플을 이용해 더 긴 인자 목록으로 fetchall을 실행해보라. 웹사이트가 응답하지 않을 경우 프로그램이 어떻게 작동하는가?